<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
	<channel>
		<title>GuoJing's Blog</title>
		<description>atleeon的博客</description>
		<link>http://atleeon.com</link>
		<atom:link href="http://atleeon.com/feed.xml" rel="self" type="application/rss+xml" />
		
			<item>
				<title>且听风吟</title>
				<description>&lt;blockquote&gt;
  &lt;p&gt;时光真疯狂，我一路执迷与匆忙&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;最近他常哼起这首歌，特别是晚上走路的时候。校园周围很多街道，唯独他记不得这条路的名字，能想起的只有夏夜摇曳的树影，偶尔轻抚皮肤上汗毛的风，温柔的无法抵抗。&lt;/p&gt;

&lt;p&gt;仿如一零年夏天，那些想不起名字的水泥地，台阶、路口的红绿灯、大院的门，小区，水池，当然，还有一个他确信自己仍记得清楚的冰淇淋店。里面发脾气的，耐心的，烦躁的，喜悦的男男女女中间，一张桌子上，放着一本留言册，胡言乱语。&lt;/p&gt;

&lt;p&gt;青春的梦想，单纯的大多只有梦和想，沉溺的会忘记仲夏的烦躁，身体间的汗味也让人迷醉。说起来，那个夏天好热啊，他们都这么说，你问他有多热，他肯定会说 “我好想去吃冰淇淋啊”。&lt;/p&gt;

&lt;p&gt;放假那天，他淋着大雨匆匆忙忙的叫到一辆的士，拼命钻进去，前往车站。临行前，他想看看窗外，可那车窗模糊的像跌进了深深的水里。后来才知道，这雨水让他的夏天以及相关的一切模糊了一片。&lt;/p&gt;

&lt;p&gt;后来，他试图过去寻找那些台阶啊，小区啊，但是却发现自己从没来过，只有那家冰淇淋店还在。于是他按照自己的记忆挑了个位置，桌子上真的有一本小册子，他确信自己找到了，可那日期拆穿了他。走出店门后，他发现那夏天再也找不见了。&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;后来，他不知不觉就很忙了。但是他还是常常在想那些被雨冲走的日子呢？他常停下来，猜测这这风中就有线索。&lt;/p&gt;

&lt;p&gt;“这条路究竟是要去哪儿，大风声，像没发生 太多的记忆。。。”他感觉有点凉了，哼着歌走了。&lt;/p&gt;

&lt;p&gt;又后来，他就没再找了。&lt;/p&gt;

&lt;p class=&quot;center&quot;&gt;&lt;img src=&quot;http://cdn4atleeon.qiniudn.com/image/story/2014/wind.jpg&quot; alt=&quot;雨&quot; style=&quot;max-width:700px&quot; /&gt;&lt;/p&gt;

&lt;p class=&quot;center&quot;&gt;Photo by searna&lt;/p&gt;

&lt;p&gt;以上。&lt;/p&gt;
</description>
				<pubDate>Tue, 13 May 2014 00:00:00 +0800</pubDate>
				<link>http://atleeon.com/story/2014/05/13/listen-to-wind/</link>
				<guid isPermaLink="true">http://atleeon.com/story/2014/05/13/listen-to-wind/</guid>
			</item>
		
			<item>
				<title>Python中的元类</title>
				<description>&lt;p&gt;翻译一篇来自StackOverflow的回答，原问题地址&lt;a href=&quot;http://stackoverflow.com/questions/100003/what-is-a-metaclass-in-python&quot;&gt;What is a metaclass in Python&lt;/a&gt;. 投票最高的答案非常完整描述了Python Metaclass机制。说起元类，大致可以才想到其作用，关于类的类。&lt;strong&gt;元&lt;/strong&gt;或者&lt;strong&gt;meta&lt;/strong&gt;常用来表示关于一个事物本身的属性。比如一份学生名单，这份数据的格式doc, 字数1000字，这就是这份数据的元数据，而文本描述的学生信息就是具体的数据本身，元数据描述了这份数据。你有可能听说过元编程,道理也是一样，编写去生产代码的程序。那么元类呢？&lt;/p&gt;

&lt;!-- break --&gt;

&lt;p&gt;下面为原文部分&lt;/p&gt;

&lt;h2 id=&quot;section&quot;&gt;类也是对象&lt;/h2&gt;
&lt;p&gt;在理解元类之前，你需要掌握Python中类的概念。Python中对于类的处理借鉴了Smalltalk语言。在大多数编程语言中，类只是用来生成对象的代码，从这方面来讲，Python也是一样的：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; class ObjectCreator(object):
...     pass
...
&amp;gt;&amp;gt;&amp;gt; my_object = ObjectCreator() #实例化一个对象
&amp;gt;&amp;gt;&amp;gt; print(my_object)
&amp;lt;__main__.ObjectCreator object at 0x8974f2c&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;但是Python类还有更特殊的身份：类也是对象。当你使用&lt;strong&gt;class&lt;/strong&gt;关键字的时候，Python会执行并创建一个对象.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; class ObjectCreator(object):
...     pass
...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面的代码在内存中创建一个名字为ObjectCreator的对象.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;这个对象(类)本身具有创建对象(实例)的能力，因此它成为一个类&lt;/strong&gt;. 但是其本身仍然是个对象，因此:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;可以将类赋值给一个变量&lt;/li&gt;
  &lt;li&gt;可以复制类&lt;/li&gt;
  &lt;li&gt;可以给类添加属性&lt;/li&gt;
  &lt;li&gt;可以把类作为函数参数传递&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;举例:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; print(ObjectCreator) # 你可以打印一个类，因为它也是一个对象
&amp;lt;class&#39;__main__.ObjectCreator&#39;&amp;gt;
&amp;gt;&amp;gt;&amp;gt; def echo(o):
... print(o)
...
&amp;gt;&amp;gt;&amp;gt; echo(ObjectCreator) # 也可以把类作为函数参数
&amp;lt;class&#39;__main__.ObjectCreator&#39;&amp;gt;
&amp;gt;&amp;gt;&amp;gt; print(hasattr(ObjectCreator,&#39;new_attribute&#39;))
False
&amp;gt;&amp;gt;&amp;gt; ObjectCreator.new_attribute =&#39;foo&#39; # 可以给类添加新的属性
&amp;gt;&amp;gt;&amp;gt; print(hasattr(ObjectCreator,&#39;new_attribute&#39;))
True
&amp;gt;&amp;gt;&amp;gt; print(ObjectCreator.new_attribute)
foo
&amp;gt;&amp;gt;&amp;gt; ObjectCreatorMirror = ObjectCreator # 把类赋值给其他变量
&amp;gt;&amp;gt;&amp;gt; print(ObjectCreatorMirror.new_attribute)
foo 
&amp;gt;&amp;gt;&amp;gt; print(ObjectCreatorMirror())
&amp;lt;__main__.ObjectCreator object at 0x8997b4c&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;section-1&quot;&gt;动态的创建类&lt;/h2&gt;

&lt;p&gt;因为类也是对象，所以我们可也像创建其他对象那样创建类。首先，可以在函数中使用 &lt;strong&gt;class&lt;/strong&gt; 创建类：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; def choose_class(name):
...     if name ==&#39;foo&#39;:
...         class Foo(object):
...             pass
...         return Foo # 返回类本身，而不是实例
...     else:
...         class Bar(object):
...             pass
...         return Bar
...
&amp;gt;&amp;gt;&amp;gt; MyClass = choose_class(&#39;foo&#39;)
&amp;gt;&amp;gt;&amp;gt; print(MyClass) # 函数返回一个类而不是实例
&amp;lt;class&#39;__main__.Foo&#39;&amp;gt;
&amp;gt;&amp;gt;&amp;gt; print(MyClass()) # 可以通过这个类创建对象
&amp;lt;__main__.Foo object at 0x89c6d4c&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;但这并不是真正的动态创建，你还是需要自己编写全部所需的代码。因为类也是对象，所以它一定可以通过某种方式生成，当你使用&lt;strong&gt;class&lt;/strong&gt;关键字的时候，Python自动创建对象。但是就像Python中很多机制一样，它允许你自己手动控制。&lt;/p&gt;

&lt;p&gt;还记得&lt;code&gt;type&lt;/code&gt;函数吗？这个有点历史并且很棒的函数可以判断一个对象是什么类型：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; print(type(1)) 
&amp;lt;type &#39;int&#39;&amp;gt;
&amp;gt;&amp;gt;&amp;gt; print(type(&quot;1&quot;)) 
&amp;lt;type &#39;str&#39;&amp;gt;
&amp;gt;&amp;gt;&amp;gt; print(type(ObjectCreator)) 
&amp;lt;type &#39;type&#39;&amp;gt;
&amp;gt;&amp;gt;&amp;gt; print(type(ObjectCreator())) 
&amp;lt;class&#39;__main__.ObjectCreator&#39;&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;其实，&lt;code&gt;type&lt;/code&gt;还有一个完全不同的功能，它可以在运行时创建类。&lt;code&gt;type&lt;/code&gt;可以接受一个描述类的参数，并且返回一个类。(针对不同的参数有两个完全不同功能的函数看起来挺愚蠢。这是Python向后兼容的问题)。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;type&lt;/code&gt;方法工作方式如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;type(name of the class,      
    tuple of the parent class(for inheritance, can be empty),      
    dictionary containing attributes names and values)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;例如：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; class MyShinyClass(object):
...     pass
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这个类可以通过下面的方式创建：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; MyShinyClass= type(&#39;MyShinyClass&#39;,(),{}) # 返回一个对象
&amp;gt;&amp;gt;&amp;gt; print(MyShinyClass)
&amp;lt;class&#39;__main__.MyShinyClass&#39;&amp;gt;
&amp;gt;&amp;gt;&amp;gt; print(MyShinyClass()) # 用创建的类实例化一个对象
&amp;lt;__main__.MyShinyClass object at 0x8997cec&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;注意到，我们使用 &lt;code&gt;MyShinyClass&lt;/code&gt;作为类的名字，并且引用它。这个名字可以不同，但是没有必要把事情变得更加复杂(一个就够了吧)。&lt;code&gt;type&lt;/code&gt;方法接受一个字典参数来定义类的属性：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; class Foo(object):
...       bar = True
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以转换为：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; Foo = type(&#39;Foo&#39;, (), {&#39;bar&#39;:True})
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Foo可以作为一个正常的类的使用。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; print(Foo)
&amp;lt;class&#39;__main__.Foo&#39;&amp;gt;
&amp;gt;&amp;gt;&amp;gt; print(Foo.bar)
True
&amp;gt;&amp;gt;&amp;gt; f = Foo()
&amp;gt;&amp;gt;&amp;gt; print(f)
&amp;lt;__main__.Foo object at 0x8a9b84c&amp;gt;
&amp;gt;&amp;gt;&amp;gt; print(f.bar)
True
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;当然你也可以继承这个类：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; class FooChild(Foo):
...     pass
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;换成动态写法：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; FooChild = type(&#39;FooChild&#39;,(Foo,),{})
&amp;gt;&amp;gt;&amp;gt; print(FooChild)
&amp;lt;class&#39;__main__.FooChild&#39;&amp;gt;
&amp;gt;&amp;gt;&amp;gt; print(FooChild.bar) # bar继承自Foo
True
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;最后如果想给自己创建的类添加方法，只要定义一个合适的方法并且将其赋值给类的属性就可以了&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; def echo_bar(self):
...     print(self.bar)
... 
&amp;gt;&amp;gt;&amp;gt; FooChild = type(&#39;FooChild&#39;,(Foo,),{&#39;echo_bar&#39;: echo_bar})
&amp;gt;&amp;gt;&amp;gt; hasattr(Foo,&#39;echo_bar&#39;)
False
&amp;gt;&amp;gt;&amp;gt; hasattr(FooChild,&#39;echo_bar&#39;)
True
&amp;gt;&amp;gt;&amp;gt; my_foo =FooChild()
&amp;gt;&amp;gt;&amp;gt; my_foo.echo_bar()
True
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以看到，在Python中我们可以在运行时动态创建类，这就是class关键字真正执行的操作，利用了元类。&lt;/p&gt;

&lt;h2 id=&quot;section-2&quot;&gt;什么是元类&lt;/h2&gt;
&lt;p&gt;元类是用来创建类的，你定义class来创建类，对吧？但是我们了解到Python的类其实也是对象。总之元类就是类的类，你可以用下面的方式描述它：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;MyClass=MetaClass()
MyObject=MyClass()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我们知道&lt;code&gt;type&lt;/code&gt;方法允许我们做下面的这种事情：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;MyClass= type(&#39;MyClass&#39;,(),{})
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这是因为type函数实际上是一个元类，Python用它来创建所有对象。你也许会想为什么&lt;code&gt;type&lt;/code&gt;全写成小写而不是&lt;code&gt;Type&lt;/code&gt;，我猜是为了和&lt;code&gt;str&lt;/code&gt;(创建字符串对象的类)，&lt;code&gt;int&lt;/code&gt;(创建整型对象的类)保持一致.你可以通过&lt;strong&gt;__class__&lt;/strong&gt;属性查看。&lt;/p&gt;

&lt;p&gt;Python中一切都是对象，包括所有的字符串，整型 ，函数和类。他们都是通过某个类创建的：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; age = 35
&amp;gt;&amp;gt;&amp;gt; age.__class__
&amp;lt;type &#39;int&#39;&amp;gt;
&amp;gt;&amp;gt;&amp;gt; name = &#39;bob&#39;
&amp;gt;&amp;gt;&amp;gt; name.__class__
&amp;lt;type &#39;str&#39;&amp;gt;
&amp;gt;&amp;gt;&amp;gt; def foo():
pass
&amp;gt;&amp;gt;&amp;gt; foo.__class__
&amp;lt;type &#39;function&#39;&amp;gt;
&amp;gt;&amp;gt;&amp;gt; classBar(object):
        pass
&amp;gt;&amp;gt;&amp;gt; b = Bar()
&amp;gt;&amp;gt;&amp;gt; b.__class__
&amp;lt;class&#39;__main__.Bar&#39;&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;那么 &lt;code&gt;__class__.__class__&lt;/code&gt;代表什么呢？&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; age.__class__.__class__
&amp;lt;type &#39;type&#39;&amp;gt;
&amp;gt;&amp;gt;&amp;gt; name.__class__.__class__
&amp;lt;type &#39;type&#39;&amp;gt;
&amp;gt;&amp;gt;&amp;gt; foo.__class__.__class__
&amp;lt;type &#39;type&#39;&amp;gt;
&amp;gt;&amp;gt;&amp;gt; b.__class__.__class__
&amp;lt;type &#39;type&#39;&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以看出元类就是创建类的，你可以给它叫做类工厂，&lt;code&gt;type&lt;/code&gt;是Python的内置元类，当然你也可以创建自己的元类。&lt;/p&gt;

&lt;h2 id=&quot;metaclass&quot;&gt;__metaclass__属性&lt;/h2&gt;

&lt;p&gt;创建一个类的时候，可以给它添加 &lt;code&gt;__classmeta__&lt;/code&gt;属性：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;class Foo(object):  
    __metaclass__ = something...
    [...]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这样做，Python就会使用指定的元类创建Foo类。这个要小心处理。你首先要写&lt;code&gt;class Foo(object)&lt;/code&gt;，但是Foo类此时还没有被创建。Python会寻找&lt;code&gt;__metaclass__&lt;/code&gt;的定义，如果找到就是用它创建Foo，如果没有找到，就使用type创建。&lt;/p&gt;

&lt;p&gt;记住下面的步骤：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;class Foo(Bar):
    pass
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Python会做下面的事情：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;检查Foo中是不是有__metaclass__属性&lt;/li&gt;
  &lt;li&gt;如果有，创建一个类对象，名字为Foo,通过__metaclass__指定的类创建&lt;/li&gt;
  &lt;li&gt;如果Python找不到__metaclass__，它会在父类Bar中寻找__metaclass__，重复相同的规则&lt;/li&gt;
  &lt;li&gt;如果在任何父类中都找不到__metaclass__，就会到MODULE中去找，重复相同规则&lt;/li&gt;
  &lt;li&gt;如果还找不到，则使用type创建&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;__metaclass__到底应该放什么呢？就是创建类&lt;/p&gt;

&lt;h2 id=&quot;section-3&quot;&gt;自定义元类&lt;/h2&gt;

&lt;p&gt;元类的主要目的是动态改变类。常见的使用场景是创建API,你需要根据运行环境创建类。考虑一个笨拙的例子，你希望模块中所有的类属性都改为大写的。这有几种实现方式，其中之一就是在模块中设置__metaclass__。&lt;/p&gt;

&lt;p&gt;这样，模块中所有的类都是通过这个元类创建的，我们只需要告诉元类把所有的类属性改为大写。幸运的是，__metaclass__可以以任何形式调用，不一定是正式的class。&lt;/p&gt;

&lt;p&gt;所以我们用一个简单例子开始，使用函数：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# 这个元类接收和type相同的参数
def upper_attr(future_class_name, future_class_parents, future_class_attr):
    &quot;&quot;&quot;    
      返回一个类对象，其属性转换为大写
    &quot;&quot;&quot;
    # 选择不是__开头的属性，并且转换为大写  
    uppercase_attr ={}
    for name, val in future_class_attr.items():
        if not name.startswith(&#39;__&#39;):
            uppercase_attr[name.upper()]= val      
        else:          
            uppercase_attr[name]= val  
    # 使用type创建类
    return type(future_class_name, future_class_parents, uppercase_attr)

    __metaclass__ = upper_attr # 作用于模块中所有的类

class Foo():
    # 我们也可以在这里指定__metaclass__只作用于这一个类
    # 这会影响子类 
    bar =&#39;bip&#39;

print(hasattr(Foo,&#39;bar&#39;))
# Out: False
print(hasattr(Foo,&#39;BAR&#39;))
# Out: True
f = Foo()
print(f.BAR)
# Out: &#39;bip&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;现在实现相同的效果,使用真实的类作为元类：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# 注意type和int ，str一样，所以你可以继承它
class UpperAttrMetaclass(type):# __new__ 在 __init__之前被调用
    # 这个方法负责创建并且返回对象
    # __init__ 方法只是初始化对象参数
    # 平时很少用 __new__, 除非你想要控制对象的创建
    def __new__(upperattr_metaclass, future_class_name,                 
                future_class_parents, future_class_attr):

        uppercase_attr ={}
        for name, val in future_class_attr.items():
            if not name.startswith(&#39;__&#39;): 
                uppercase_attr[name.upper()]= val            
            else:
                uppercase_attr[name]= val

        return type(future_class_name, future_class_parents, uppercase_attr)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;实际上这种方式并不是真正的面向对象，我们直接调用了type，没有重载父类的__new__方法，这样改写一下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;class UpperAttrMetaclass(type):# __new__ 在 __init__之前被调用

    def __new__(upperattr_metaclass, future_class_name,                 
                future_class_parents, future_class_attr):

        uppercase_attr ={}
        for name, val in future_class_attr.items():
            if not name.startswith(&#39;__&#39;): 
                uppercase_attr[name.upper()]= val            
            else:
                uppercase_attr[name]= val

        # 重用type.__new__ method
        return type.__new__(upperattr_metaclass, future_class_name,
                            future_class_parents, uppercase_attr)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;你可能发现了额外的参数uperattr_metaclass,这个参数是对象方法总是将当前实例作为第一个参数传入。当然我使用的这个名字不够明确，就像self，所有参数都有规定名字，所以真实的元类应该是这样的&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;class UpperAttrMetaclass(type):# __new__ 在 __init__之前被调用

    def __new__(cls, clsname, bases, dct):

        uppercase_attr ={}
        for name, val in future_class_attr.items():
            if not name.startswith(&#39;__&#39;): 
                uppercase_attr[name.upper()]= val            
            else:
                uppercase_attr[name]= val

        return type.__new__(cls, clsname, bases, uppercase_attr)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我们可以使用super关键字使代码变得更加清晰&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;class UpperAttrMetaclass(type):# __new__ 在 __init__之前被调用

    def __new__(cls, clsname, bases, dct):

        uppercase_attr ={}
        for name, val in future_class_attr.items():
            if not name.startswith(&#39;__&#39;): 
                uppercase_attr[name.upper()]= val            
            else:
                uppercase_attr[name]= val

        return super(UpperAttrMetaclass,cls).__new__(cls, clsname, bases, uppercase_attr)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;关于元类真的就是这么多了，使用元类的代码错综复杂的原因不是因为元类，而是因为你通常使用元类在自省，继承和__dict__这样的变量上进行依赖反转。&lt;/p&gt;

&lt;p&gt;事实上元类在使用一些”黑魔法”时很有用，这也使事情更复杂，但是他们本身很简单：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;拦截一个类创建的过程&lt;/li&gt;
  &lt;li&gt;修改类&lt;/li&gt;
  &lt;li&gt;返回修改后的类&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section-4&quot;&gt;为什么使用类做元类而不是函数&lt;/h2&gt;

&lt;p&gt;元类接受任何形式调用（上面显示了两种基本方式，通过函数和类），使用类作为元类显然更加复杂，为什么这样做的？&lt;/p&gt;

&lt;p&gt;原因有几个：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;意图清晰，当你阅读&lt;code&gt; UpperAttrMetaclass(type)&lt;/code&gt;,你知道接下来要做什么&lt;/li&gt;
  &lt;li&gt;利用面向对象，元类可以继承自元类，覆写父类的方法，元类甚至可以使用元类&lt;/li&gt;
  &lt;li&gt;可以更好的控制代码结构，你不可能用元类处理像上面那样微不足道的例子，通常是处理比较复杂的情景，使用类可以将不同方法封装到一起，是的代码更加容易阅读&lt;/li&gt;
  &lt;li&gt;你可以在&lt;code&gt;__new__&lt;/code&gt;,&lt;code&gt;__init__&lt;/code&gt;,&lt;code&gt;__call__&lt;/code&gt;使用hook，这样可以处理不同的事情，或许你可能喜欢把所有代码写到&lt;code&gt;__new__&lt;/code&gt;里，其他人可能觉得&lt;code&gt;__init__&lt;/code&gt;更方便&lt;/li&gt;
  &lt;li&gt;这东西本来就叫元“类”！&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section-5&quot;&gt;到底为什么用元类&lt;/h2&gt;
&lt;p&gt;最大的问题来了，为什么使用这么复杂的特性呢？&lt;/p&gt;

&lt;p&gt;事实上，通常不会使用：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;元类是99%开发者不会考虑的特性，如果你疑惑自己是不是需要他们，那么一般答案是，不需要。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;元类的主要用处是创建API,一个典型的例子是Django ORM. 它允许你这样定义类：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;class Person(models.Model):
    name = models.CharField(max_length=30)
    age = models.IntegerField()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;但是如果你这样做：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;guy = Person(name=&#39;bob&#39;,age=&#39;35&#39;)
print(guy.age)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;它就不会返回一个&lt;code&gt;IntegerField&lt;/code&gt;，而是返回一个&lt;code&gt;int&lt;/code&gt;，甚至直接从数据库中读取。这是有可能的，因为&lt;code&gt;models.Model&lt;/code&gt;定义了&lt;code&gt;__metaclass__&lt;/code&gt;，并且它可能会改变你定义的&lt;code&gt;Person&lt;/code&gt;类，使得它Hook到数据库的某个字段。Django将复杂的hook用简单的API呈现，并且使用元类重新创建代码来完成背后真正复杂的工作。&lt;/p&gt;

&lt;h2 id=&quot;section-6&quot;&gt;最后&lt;/h2&gt;
&lt;p&gt;首先你要知道类是对象，并且可以创建对象，然而事实上类自己也是一个实例&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; class Foo(object):pass
&amp;gt;&amp;gt;&amp;gt; id(Foo)
142630324
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Python中一切都是对象，他们要么是类的实例，要么是元类的实例。&lt;/p&gt;

&lt;p&gt;type除外。type是它自己的元类，这是在实现层完成的。其次元类是复杂的，你可能不希望使用它进行简单的类变换，你可以使用下面的方式改变类：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Monkey patching&lt;/li&gt;
  &lt;li&gt;类装饰器&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;如果你需要修改类，99%的情况下，你最好使用上面两个方法，但是99%的情况下，你根本不需要修改类。。。。。&lt;/p&gt;
</description>
				<pubDate>Fri, 14 Mar 2014 00:00:00 +0800</pubDate>
				<link>http://atleeon.com/code/2014/03/14/trans-python-metaclass/</link>
				<guid isPermaLink="true">http://atleeon.com/code/2014/03/14/trans-python-metaclass/</guid>
			</item>
		
			<item>
				<title>JavaScript Scoping and Hoisting</title>
				<description>&lt;blockquote&gt;
  &lt;p&gt;看到一篇好的文章,忍不住要翻译一下了,本文来自twitter工程师 ben cherry的&lt;a href=&quot;http://www.adequatelygood.com/JavaScript-Scoping-and-Hoisting.html&quot;&gt;JavaScript Scoping and Hoisting&lt;/a&gt;,主要讲解了JavaScript中的变量和函数声明的解析顺序，阅读本文之前,读者最好掌握了JavaScript中变量对象VO、函数声明FD以及函数表达式FE的概念.考虑到作者没有详细解释的部分,我进行了代码演示以及文字补充。翻译不恰当的地方,欢迎交流指出。
&lt;!-- break --&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;section&quot;&gt;正文&lt;/h2&gt;
&lt;p&gt;你知道下面的JavaScript程序执行后,alert会得到什么结果吗？&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var foo = 1;
function bar() {
    if (!foo) {
        var foo = 10;
    }
    alert(foo);
}
bar();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;答案是 10,如果你觉得很意外，那么下面这个可能就会更让你震惊了.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var a = 1;
function b() {
    a = 10;
    return;
    function a() {}
}
b();
alert(a);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这段代码在浏览器中执行会显示1.为什么呢？尽管这个例子看起来比较奇怪，令人疑惑，但这恰恰正是JavaScript语言的一个强大的特性.我不知道是不是有一个标准的名字来描述这种机制，但是我喜欢用“hoisting”这个词.这篇文章将会解开这种机制(hoisting)的面纱。开始之前，先让我们先去理解一下JavaScript的作用域吧.&lt;/p&gt;

&lt;h2 id=&quot;javascript&quot;&gt;JavaScript中的作用域&lt;/h2&gt;

&lt;p&gt;对于JavaScript初学者来讲，最容易迷惑的就是作用域。事实上，不仅仅是初学者，我遇到过很多有经验的JavaScript程序员也不完全理解作用域。JavaScript的作用域如此难以理解的原因或许是它看起来像C语言家族的语言，看下面的代码：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#include &amp;lt;stdio.h&amp;gt;
int main() {
    int x = 1;
    printf(&quot;%d, &quot;, x); // 1
    if (1) {
        int x = 2;
        printf(&quot;%d, &quot;, x); // 2
    }
    printf(&quot;%d\n&quot;, x); // 1
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;程序的输出是1,2,1.原因是C语言以及其家族语言，拥有块级作用域。当程序进入一个块区域，比如if-else语句的时候，一个新的作用域就被创建了，你可以在里面定义新的变量，而不会影响其他作用域。但这种机制并不适用于JavaScript，看下面的代码：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var x = 1;
console.log(x); // 1
if (true) {
    var x = 2;
    console.log(x); // 2
}
console.log(x); // 2
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面的代码在firebug中会显示1，2，2.这是因为JavaScript拥有函数级的作用域，这与C家族的语言非常不同。在JavaScript中块，例如if语句，不会创建一个新的作用域，只有函数才会创建新的作用域。&lt;/p&gt;

&lt;p&gt;对于许多习惯了C, C++, C# 或者 Java这样的语言的程序员，这个特性显得很不友好。幸运的是，得益于JavaScript函数的灵活性，还是有变通方法的，如果你需要在函数内部创建一个临时的作用域，可以使用（立即执行函数表达式IIFE）:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;function foo() {
    var x = 1;
    if (x) {
        (function () {
            var x = 2;
            // some other code
        }());
    }
    // x is still 1.
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这种方法其实非常灵活，你可以在任何地方创建临时的作用域，不仅仅是块语句中。然而，我强烈建议花点时间真正的理解和接受JavaScript作用域。它非常的强大，并且是我最喜欢的JavaScript特性之一。如果你理解了作用域，那么hoisting就更容易理解了。&lt;/p&gt;

&lt;h3 id=&quot;section-1&quot;&gt;声明, 变量名, 和声明提升&lt;/h3&gt;

&lt;p&gt;在JavaScript中一个变量名可以通过下面四个方式进入一个作用域:(也就是被当前作用域识别)&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;语言内置定义Language-defined：所有作用域都默认包含this 和 arguments变量。&lt;/li&gt;
  &lt;li&gt;函数形式参数Formal parameters：函数可以拥有形式参数,并且在其函数体作用域内生效。&lt;/li&gt;
  &lt;li&gt;函数声明Function declarations：形如function foo() {}的声明。&lt;/li&gt;
  &lt;li&gt;变量声明Variable declarations: 形如var foo;的声明。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;函数声明和变量声明总是被JavaScript解释器移动到作用域的顶部(hoisting).函数的参数和语言内置定义的变量很显然在这之前已经在那了。这意味着下面的代码：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;function foo() {
    bar();
    var x = 1;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;其实被解释成了这样:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;function foo() {
    var x;
    bar();
    x = 1;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;有一种情况是声明所在的语句根本不会执行，但这并不影响hoisting机制,下面两个函数就是等效的：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;function foo() {
    if (false) {
        var x = 1;
    }
    return;
    var y = 1;
}
function foo() {
    var x, y;
    if (false) {
        x = 1;
    }
    return;
    y = 1;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;注意有时声明和赋值会一起写，但是赋值部分并不会&lt;strong&gt;提升(hoist)&lt;/strong&gt;，只有变量名会被提升。对于函数声明，整个函数名和函数体都会得到提升。但是记住函数声明有两种方式，思考下面的JavaScript代码：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;function test() {
    foo(); // TypeError &quot;foo is not a function&quot;
    bar(); // &quot;this will run!&quot;
    var foo = function () { // function expression assigned to local variable &#39;foo&#39;
        alert(&quot;this won&#39;t run!&quot;);
    }
    function bar() { // function declaration, given the name &#39;bar&#39;
        alert(&quot;this will run!&quot;);
    }
}
test();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这种情形下，bar函数声明的函数体被提升到顶部了,foo这个变量被提升了，但是他对应的函数体仍在原来的位置，执行到那里的时候才会赋值。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;补充：原作者在这里并没有详细的介绍函数声明FD和函数表达式FE的概念，上面代码中bar对应的是一个函数声明，而foo对应的语句是一个函数表达式。bar所在的语句是一个完整的函数声明，所以会全部得到提升，而foo所在的语句严格来讲并不是一个函数声明，他可以分为两部分：一是声明了一个普通变量foo,然后把一个函数赋值给foo.因此声明foo变量的语句会提升，而后面的函数部分则不会。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;前面包含了hoisting的基本概念，看起来并不是那么复杂令人疑惑.当然在一些特定的场景下，还是有点复杂的。&lt;/p&gt;

&lt;h2 id=&quot;section-2&quot;&gt;变量识别顺序&lt;/h2&gt;

&lt;p&gt;我们要记住的重要的特例是变量的识别顺序。前面提到过变量名进入作用域有四种方式。刚刚我们列出的顺序就是他们被识别的顺序。通常，如果一个变量名已经被定义了，它就不会被另一个相同名字的变量覆盖(后者被忽略)。这意味着函数声明比函数变量声明有着更高的优先级。但是这并不影响对这个变量的赋值会继续进行，只是声明部分被忽略了。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;补充一段代码，表达原作者的意思：&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code&gt;function foo(){}
var foo = 3;
console.log(foo);//3
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这个例子会被解释器解释为：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;function foo(){}
//var foo;  //这条语句就被忽略了。
foo = 3;
console.log(foo) 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;接原文，当然也有一些例外:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;内置的变量arguments表现的比较怪异。它看起来优先级位于函数形式参数和函数声明之间，这意味着如果形式参数中存在一个叫做arguments的变量，将比语言内置的arguments拥有更高的声明优先级.这是一个不好的特性，不要使用arguments作为形式参数。&lt;/li&gt;
  &lt;li&gt;在任何地方使用this作为标示符都会导致一个语法错误，这是一个好的特性。&lt;/li&gt;
  &lt;li&gt;如果多个形式参数拥有相同的名字，那么最后一个将拥有最高的优先级，即使它是undefined。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section-3&quot;&gt;带有名字的的函数表达式&lt;/h2&gt;

&lt;p&gt;你也可以给函数表达式中的函数起一个名字，采用类似函数声明的语法。但这并不能使它变成一个函数声明，并且这个名字也不会添加到作用域，函数体也不会被提升。下面的代码演示了我所说的：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;foo(); // TypeError &quot;foo is not a function&quot;
bar(); // valid
baz(); // TypeError &quot;baz is not a function&quot;
spam(); // ReferenceError &quot;spam is not defined&quot;

var foo = function () {}; // anonymous function expression (&#39;foo&#39; gets hoisted)
function bar() {}; // function declaration (&#39;bar&#39; and the function body get hoisted)
var baz = function spam() {}; // named function expression (only &#39;baz&#39; gets hoisted)

foo(); // valid
bar(); // valid
baz(); // valid
spam(); // ReferenceError &quot;spam is not defined&quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;section-4&quot;&gt;用这些知识编程&lt;/h2&gt;

&lt;p&gt;现在你已经理解了作用域和声明提升，这对于JavaScript编程意味着什么呢？最重要的就是你应该总是使用&lt;strong&gt;var&lt;/strong&gt;关键字来声明变量。我强烈的建议你在每一个作用域的顶部恰好写一个var语句(多变量的时候，用逗号连接)。如果你要求自己这么做，就不会遇到hoisting相关的困惑了。不过，这么做会让你寻找当前作用域中声明的变量变得更困难。我建议使用JSLint的onevar选项来加强这些，例如下面的代码：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;/*jslint onevar: true [...] */
function foo(a, b, c) {
    var x = 1,
        bar,
        baz = &quot;something&quot;;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;section-5&quot;&gt;标准怎么说&lt;/h2&gt;

&lt;p&gt;我发现通常直接参考&lt;a href=&quot;http://www.mozilla.org/js/language/E262-3.pdf&quot;&gt;ECMAScript Standard (pdf)&lt;/a&gt; 来理解这些机制非常的有效。这是标准中关于变量定义和作用域的描述：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;如果变量语句出现在一个函数声明内部，涉及的变量就会定义在函数内部作用域,参考章节10.1.3. 否则，他们就会被定义在全局作用域内(作为global对象的一个属性)，参考章节 10.1.3。 变量在进入作用域的时候被创建。一个block不能定义一个执行环境作用域。只有程序和函数声明可以创建作用域。变量在创建的时候会被初始化为undefined。一个带有初始化语句的变量在赋值语句执行的时候才会被赋上其赋值表达式对应的值，赋值并不是发生在变量创建的时候。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;读完这篇文章建议去知乎上challenge一下这个&lt;a href=&quot;http://www.zhihu.com/question/22949631&quot;&gt;问题&lt;/a&gt;：） &lt;/p&gt;

&lt;p&gt;以上。&lt;/p&gt;

</description>
				<pubDate>Thu, 06 Mar 2014 00:00:00 +0800</pubDate>
				<link>http://atleeon.com/code/2014/03/06/javascript-scoping-hoisting/</link>
				<guid isPermaLink="true">http://atleeon.com/code/2014/03/06/javascript-scoping-hoisting/</guid>
			</item>
		
			<item>
				<title>JavaScript 中的DOM事件</title>
				<description>&lt;h2 id=&quot;intro&quot;&gt;Intro&lt;/h2&gt;

&lt;p&gt;本文描述的 事件 是W3C定义的API, 这些事件应用在JavaScript对于DOM的操作（Node.js中也有相应的事件机制）。事件主要是监控发生在DOM元素上面的行为，当一个元素的状态改变的时候，比如点击了页面上的某个标签，就会触发事件。&lt;/p&gt;

&lt;!-- break --&gt;
&lt;p&gt;##Basic Concepts
###document
首先回顾一下DOM(Document Object Model)相关的一些基本概念。HTML文档是一棵树的形式组织的，不同的标签被转换成一个节点,这是有了这些节点，JavaScript才能自如的操作页面元素。比如下面的代码：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;html&amp;gt;
&amp;lt;head&amp;gt;
  &amp;lt;title&amp;gt;My Document&amp;lt;/title&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;
  &amp;lt;h1&amp;gt;Header&amp;lt;/h1&amp;gt;
  &amp;lt;p&amp;gt;Paragraph&amp;lt;/p&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;浏览器在渲染这个页面的时候，会以树的形式组织页面，如下图：&lt;/p&gt;

&lt;p class=&quot;center&quot;&gt;&lt;img src=&quot;http://cdn4atleeon.qiniudn.com/image/code/2014dom-tree.jpeg&quot; alt=&quot;&quot; style=&quot;max-width:400px&quot; /&gt;&lt;/p&gt;

&lt;p class=&quot;center&quot;&gt;DOM结构&lt;/p&gt;

&lt;p&gt;可以看到树根元素就是&lt;code&gt;document&lt;/code&gt;,表示整个文档对象，通过它可以操作dom节点。比如：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var elem = document.getElementById(&#39;button&#39;);
var newELem = document.createElement(&quot;div&quot;);
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;window&quot;&gt;window&lt;/h3&gt;
&lt;p&gt;window是JavaScript中的全局变量，所有的全局变量都作为window的属性存在。使用window也可以监控浏览器的窗口事件。例如下面的代码可以关闭浏览器窗口：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;window.close();
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;eventtarget&quot;&gt;EventTarget&lt;/h3&gt;

&lt;blockquote&gt;
  &lt;p&gt;EventTarget is a DOM interface implemented by objects that can receive DOM events and have listeners for them.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;EventTarget是定义的一个接口，通过这个接口，实现对于DOM事件的支持。Element,document,和window都是最常用的EventTarget，他们还支持on..（如onCLick,现代浏览器推荐addEventListener方法）事件绑定。EventTarget还包括XMLHttpRequest,AudiNode和AudioContext等。&lt;/p&gt;

&lt;p&gt;EventTarget提供三个重要的方法：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;target.addEventListener(type, listener[, useCapture]);&lt;/li&gt;
  &lt;li&gt;target.removeEventListener(type, listener[, useCapture]);&lt;/li&gt;
  &lt;li&gt;canceled = !target.dispatchEvent(event);&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;using-built-in-events&quot;&gt;Using built-in events&lt;/h2&gt;

&lt;p&gt;大多数场景下，我们只需要使用内置的事件类型就足够了。DOM API提供的事件比较丰富，常用的有:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;鼠标事件 &lt;code&gt;mousedown&lt;/code&gt;,&lt;code&gt;mouse up&lt;/code&gt;,&lt;code&gt;click&lt;/code&gt;,&lt;code&gt;mouseover&lt;/code&gt;,&lt;code&gt;mouseout&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;键盘事件 &lt;code&gt;keypress&lt;/code&gt;,&lt;code&gt;keydown&lt;/code&gt;,&lt;code&gt;keyup&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;表单事件 &lt;code&gt;select&lt;/code&gt;,&lt;code&gt;change&lt;/code&gt;,&lt;code&gt;submit&lt;/code&gt;,&lt;code&gt;focus&lt;/code&gt;,&lt;code&gt;reset&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;页面事件 &lt;code&gt;load&lt;/code&gt;,&lt;code&gt;scroll&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;假如我们的网页有下面的结构：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;div&amp;gt;&amp;lt;a id=&quot;bt&quot; href=&quot;octsky.com&quot;&amp;gt;Click me!&amp;lt;/a&amp;gt;&amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在js代码中：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var bt = document.getElementByIn(&#39;bt&#39;);

function myClickHandler(e){
    alert(&#39;button is clicked.&#39;);
}

bt.addEventListener(&#39;click&#39;,myClickHandler,false);

//you can also do this:
//bt.onclick = myClickHandler;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;代码中有两个不同的绑定事件的方法，重要的区别在于第二种通过onclick赋值的方法只能给一个元素绑定一个事件，而addEventListener的方式可以实现多个事件的绑定。&lt;/p&gt;

&lt;p&gt;当我们点击&lt;code&gt;&amp;lt;a&amp;gt;&lt;/code&gt;标签的时候，浏览器会出现弹窗，然后页面跳转至&lt;code&gt;octsky.com&lt;/code&gt;的页面，如果我们不希望页面跳转，阻止a标签的默认行为，使用&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;e.preventDefault();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这里&lt;code&gt;e&lt;/code&gt;是，作为Event Handler函数，默认传入的参数，代表事件本身，并且可以通过他获得事件的一些属性。&lt;/p&gt;

&lt;h2 id=&quot;creating-and-triggering-events&quot;&gt;Creating and triggering events&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;    var button = document.getElementById(&#39;button&#39;);
    var event = new Event(&#39;go&#39;);
    
    // Listen to the event
    button.addEventListener(&#39;go&#39;,function  (e) {
        alert(&#39;in go event&#39;);
    },false);
    
    // Dispatch the event
    button.dispatchEvent(event);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面的代码创建了一个自定义事件，并且绑定到了&lt;code&gt;button&lt;/code&gt;这个dom元素上，最后手动触发事件执行。这种方法大部分的现代浏览器都支持。注意addEventListener()最后一个参数，false表示不使用事件捕获，后面介绍。&lt;/p&gt;

&lt;h2 id=&quot;event-capture--bubble&quot;&gt;Event Capture &amp;amp; Bubble&lt;/h2&gt;

&lt;p&gt;前面提到了事件捕获，事件捕获是一种事件传递的机制，DOM中主要有两种事件的传递机制:&lt;strong&gt;事件捕获&lt;/strong&gt;和&lt;strong&gt;事件冒泡&lt;/strong&gt;。前者的浏览器支持不完整，后者比较完整。&lt;/p&gt;

&lt;p&gt;二者的主要区别从图中可以看出，当一个element被click的时候，如果使用事件捕获，dom跟元素document会创建事件流，一直向树叶节点元素传播，捕获事件(Capture phase),直到找到真正触发事件的目标元素，过程中，只有目标元素的事件onclick事件会在目标阶段（Target phase）触发。如果使用事件冒泡，事件从目标元素发起，向上传播，直到某个节点调用了阻止冒泡，或者到达了跟节点。过程中经过的element的click事件都会被触发，（这是事件委托的原理）。&lt;/p&gt;

&lt;p class=&quot;center&quot;&gt;&lt;img src=&quot;http://cdn4atleeon.qiniudn.com/image/code/2014event-model.jpg&quot; alt=&quot;&quot; style=&quot;max-width:400px&quot; /&gt;&lt;/p&gt;

&lt;p class=&quot;center&quot;&gt;事件冒泡与捕获&lt;/p&gt;

&lt;p&gt;addEventListener方法默认关闭事件捕获，开启事件冒泡。如果阻止事件冒泡可以使用：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;event.stopPropagation();
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;event-delegation&quot;&gt;Event delegation&lt;/h2&gt;

&lt;p&gt;事件委托是什么概念呢？一个常用的场景是列表管理。列表里有很多元素，并且是动态变化的（比如web版的文件管理器）.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;ul id=&quot;file-list&quot;&amp;gt;
    &amp;lt;li&amp;gt;item&amp;lt;/li&amp;gt;
    &amp;lt;!--many other--&amp;gt;
    &amp;lt;li&amp;gt;item&amp;lt;/li&amp;gt;   
&amp;lt;/ul&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果给每一个li元素绑定事件会非常的难以管理，这个时候利用冒泡机制的原理，可以绑定事件给&lt;code&gt;&amp;lt;ul&amp;gt;&lt;/code&gt;元素，他的每一个子元素事件触发的时候都会冒泡到父元素。再由&lt;code&gt;&amp;lt;ul&amp;gt;&lt;/code&gt;统一处理。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var filelist = document.getElementById(&#39;file-list);
filelist.addEventListener(&#39;click&#39;,function(e){
    if(e.target){
        //do something special
    }
},false);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;注意：事件委托的前提是使用事件冒泡。&lt;/p&gt;

&lt;h2 id=&quot;conclusion&quot;&gt;Conclusion&lt;/h2&gt;

&lt;p&gt;本文介绍了JavaScript DOM事件的一些基础的概念，Event是DOM的核心内容，理解基本的概念可以更好的使用一些高级的框架。&lt;/p&gt;

&lt;p&gt;推荐阅读 &lt;a href=&quot;http://www.w3.org/TR/DOM-Level-3-Events/#dom-event-architecture&quot;&gt;W3c DOM Event architecture&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;以上。&lt;/p&gt;

</description>
				<pubDate>Sat, 01 Mar 2014 00:00:00 +0800</pubDate>
				<link>http://atleeon.com/code/2014/03/01/javascript-event/</link>
				<guid isPermaLink="true">http://atleeon.com/code/2014/03/01/javascript-event/</guid>
			</item>
		
			<item>
				<title>JavaScript中的 变量、作用域链、执行上下文</title>
				<description>&lt;h2 id=&quot;intro&quot;&gt;Intro&lt;/h2&gt;

&lt;p&gt;之前一直在前端使用JavaScript,主要是操作DOM实现网页中特定的效果。接触Node.js后，JavaScript就开始在Server和Desktop上发挥作用。本文梳理一下JavaScript的一些语法上的几个核心概念,并通过一些例子来加深理解。&lt;/p&gt;

&lt;!-- break --&gt;

&lt;h2 id=&quot;execution-context&quot;&gt;Execution context&lt;/h2&gt;

&lt;p&gt;Execution context (简称EC) 是一个虚拟的概念，区分了不同的代码片段以及执行环境。JavaScript中的代码环境主要有三种，分别是Global Code, Function Code和Eval Code. 其中Global code是&lt;code&gt;.js&lt;/code&gt;文件中直接执行的代码，或者&lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt;标签中的内容。Function code是进入函数调用时候进入的代码环境。Eval code 是指使用&lt;code&gt;eval()&lt;/code&gt;的代码内容。&lt;/p&gt;

&lt;p&gt;在程序运行过程中，一系列的 execution context 构成了一个context stack。比如，程序一开始就进入了Global context，存在栈底。每当进入一个新的context，就会压栈，栈顶的内容是当前活跃的context。下图演示了context stack的变化。&lt;/p&gt;

&lt;p class=&quot;center&quot;&gt;&lt;img src=&quot;http://dmitrysoshnikov.com/wp-content/uploads/ec-stack-changes.png&quot; alt=&quot;&quot; style=&quot;max-width:400px&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Execution context 包含了主要三个部分，Variable object,Scope Chain和this. JavaScript运行时记录和查找变量就是依靠的这些结构。&lt;/p&gt;

&lt;p class=&quot;center&quot;&gt;&lt;img src=&quot;http://dmitrysoshnikov.com/wp-content/uploads/execution-context.png&quot; alt=&quot;&quot; style=&quot;max-width:400px&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;vo--ao&quot;&gt;VO &amp;amp; AO&lt;/h2&gt;

&lt;h4 id=&quot;variable-object-vo&quot;&gt;Variable Object （VO）&lt;/h4&gt;

&lt;p&gt;vo是一个与context相关联的一个特殊的object。所谓关联，就是VO存储着在当前context中声明的变量和函数声明（注：是FD而非FE）,当程序试图寻找某一个变量的时候，就会首先检查VO.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var foo = 10;
function bar() {} // function declaration, FD
(function baz() {}); // function expression, FE
 
console.log(
  this.foo == foo, // true
  window.bar == bar // true
);
 
console.log(baz); // ReferenceError, &quot;baz&quot; is not defined
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;下图显示了上面代码，Global context中VO的属性，即变量声明，和函数bar的声明，而没有baz.因为后者属于函数表达式。&lt;/p&gt;

&lt;p class=&quot;center&quot;&gt;&lt;img src=&quot;http://dmitrysoshnikov.com/wp-content/uploads/variable-object.png&quot; alt=&quot;&quot; style=&quot;max-width:400px&quot; /&gt;&lt;/p&gt;

&lt;p&gt;对于变量声明，必须使用&lt;code&gt;var&lt;/code&gt;关键字.”全局”的声明方式，只是给Global添加了一个属性，并没有严格的声明变量，也不会添加到VO,下面的代码可以验证，因为JavaScript中变量有can’t delete的特性，所以是不能删除的，而属性可以。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var temp1 = 1; //declare a variable
temp2 = 2; //actually add a new attribute to global

delete temp1;//false 
delete temp2; //true
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&quot;activation-object-ao&quot;&gt;Activation Object （AO）&lt;/h4&gt;

&lt;p&gt;在函数环境中，VO就变成了AO. 并且增加了函数参数的列表。如下面的代码对应的AO。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;function foo(x, y) {
  var z = 30;
  function bar() {} // FD
  (function baz() {}); // FE
}
foo(10, 20);
&lt;/code&gt;&lt;/pre&gt;

&lt;p class=&quot;center&quot;&gt;&lt;img src=&quot;http://dmitrysoshnikov.com/wp-content/uploads/activation-object.png&quot; alt=&quot;&quot; style=&quot;max-width:300px&quot; /&gt;&lt;/p&gt;

&lt;p&gt;JavaScript代码运行分为两个阶段，&lt;code&gt;entering the execution&lt;/code&gt; 和 &lt;code&gt;code execution&lt;/code&gt;.VO/AO在第一个阶段会被初始化，所以FD函数声明，会在第一个阶段加入到VO/AO，而FE函数表达式则不会。 &lt;/p&gt;

&lt;h2 id=&quot;scope-chain&quot;&gt;Scope Chain&lt;/h2&gt;

&lt;p&gt;作用域链是用于JavaScript寻找变量的结构，由一系列的对象组成，如果一个变量在自己所在的Scope中找不到，也就是自己VO/AO没有，（可以看出，自己的VO/AO）是作用域链的顶端）就去父节点的VO/AO去寻找。根据这个原理，JavaScript中的作用域和其他高级编程语言（利用Block区分作用域）不同，通过函数调用决定作用域链，因为函数调用会创建新的VO/AO.本Scope内不存在的变量叫做&lt;code&gt;free variable&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var x = 10;
 
(function foo() {
  var y = 20;
  (function bar() {
    var z = 30;
    // &quot;x&quot; and &quot;y&quot; are &quot;free variables&quot;
    // and are found in the next (after
    // bar&#39;s activation object) object
    // of the bar&#39;s scope chain
    console.log(x + y + z);
  })();
})();
&lt;/code&gt;&lt;/pre&gt;

&lt;p class=&quot;center&quot;&gt;&lt;img src=&quot;http://dmitrysoshnikov.com/wp-content/uploads/scope-chain.png&quot; alt=&quot;&quot; style=&quot;max-width:300px&quot; /&gt;&lt;/p&gt;

&lt;p&gt;值得注意的是JavaScript中的作用域链是静态的，当函数被创建的时候，其作用域链就是foo.[[scope]],其中[[scope]]就是globalContext.VO,当函数激活（被调用）的时候，其作用域链为AO+[[scope]].
下面的代码可以看出，foo在创建的时候,其作用域链中并没有 invokeFoo.AO，而是在其创建时刻的globalContext.VO.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var x = 1;
function foo () {
    console.log(x);
}

function invokeFoo(){
    var x = 2;
    foo();
}
invokeFoo(); // we get 1 here
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;另外一个经典的例子是循环绑定函数，结果每一次都是3，原因在于三次赋值的函数都共享了相同的[[scope]],寻找变量i的时候，其实访问都是同一个。都在Global.VO中。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var data = [];
for(var i = 0 ; i &amp;lt; 3; i++){
    data[i]=function() {
        console.log(i);
    }
}
data[0]();//get 3
data[1]();//get 3
data[2]();//get 3
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;使用闭包，改进之后。创建新函数的时候，[[scope]]都会加上匿名外面匿名函数的AO,进而获得传进来的变量。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var data = [];

for(var i = 0 ; i &amp;lt; 3; i++){
    data[i]=(function(x) {
        return function  () {
            console.log(x);
        }
    })(i);
}

data[0]();
data[1]();
data[2]();
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;this&quot;&gt;This&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;this&lt;/strong&gt; 是context中的一个属性，并不属于任何变量，因此也不能被赋值。在全局环境中，this就表示global.在函数中，this的值取决于调用当前函数的context.&lt;/p&gt;

&lt;h2 id=&quot;conclusion&quot;&gt;Conclusion&lt;/h2&gt;

&lt;p&gt;以上是JavaScript中几个基本的但是很重要的概念，有助于理解它的基本运行机制。此外还有一些重要的概念，比如函数、原型链、事件机制等。本文大部分参考了 Dmitry Soshnikov 的&lt;a href=&quot;http://dmitrysoshnikov.com/&quot;&gt;ECMA-262 Series&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;以上。&lt;/p&gt;

</description>
				<pubDate>Wed, 26 Feb 2014 00:00:00 +0800</pubDate>
				<link>http://atleeon.com/code/2014/02/26/javascript-basic/</link>
				<guid isPermaLink="true">http://atleeon.com/code/2014/02/26/javascript-basic/</guid>
			</item>
		
			<item>
				<title>写给大家看的设计书</title>
				<description>&lt;h3 id=&quot;section&quot;&gt;推荐&lt;/h3&gt;
&lt;p&gt;推荐一本非常好的入门设计书，来自Robin Williams 的《写给大家看的设计书》。之前一直以为这本书会放在计算机专业的书架上，上次在图书馆发现，原来被分类到了建筑学相关的设计类图书了。但是其实设计已经从纸质平面渐渐转移到了web和移动设备上了。作为软件专业相关的学生也值得好好的读一下。这本书读起来非常的简单明了，里面有大量的作品示例，可以感受到设计中 亲密性、重复、对比、对齐四个基本原则对于设计的提升。书中第一个小故事就吸引我了！
&lt;!-- break --&gt;
###设计与生活
编程之余，开始读原研哉的书。渐渐发觉，设计不仅仅是关于产品的，它渗透到我们的生活中的每一处。什么样的东西更美，什么样的东西更吸引人的眼球，都是设计要考虑的东西。数码领域的Apple Design 和生活中的 MUJI 都汇聚了很多优秀设计，它让生活变得更美好。如果喜欢摄影，绘画，或者做ppt，你也许就会发现，真正遇到瓶颈的不是相关的技术本身，而是设计能力，或者是创造『美』的能力。&lt;/p&gt;

&lt;h3 id=&quot;section-1&quot;&gt;笔记&lt;/h3&gt;
&lt;p&gt;下图是我整理的读书笔记，基本是按照书的结构总结的，其中&lt;code&gt;亲密性&lt;/code&gt; &lt;code&gt;对齐&lt;/code&gt;  &lt;code&gt;重复&lt;/code&gt; &lt;code&gt;对比&lt;/code&gt;四大原则是重点，后面的字体设计其实也是遵循的这些基本原则而进行。总结起来，所有的设计原则都要考虑人的视线和心理感受。从第一开始就提出了视觉单元的概念，我们的视线就在不同视觉单元中转移。&lt;/p&gt;

&lt;p class=&quot;center&quot;&gt;&lt;img src=&quot;http://cdn4atleeon.qiniudn.com/image/write/2014/%E5%86%99%E7%BB%99%E5%A4%A7%E5%AE%B6%E7%9C%8B%E7%9A%84%E8%AE%BE%E8%AE%A1%E4%B9%A6.png&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;section-2&quot;&gt;推荐资料：&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;http://mp.weixin.qq.com/mp/appmsg/show?__biz=MjM5MDMwODg2MA==&amp;amp;appmsgid=10000781&amp;amp;itemidx=3&amp;amp;sign=32a0b85ccc477079ecea7eb4f05e12d4&amp;amp;scene=3#wechat_redirect&quot;&gt;工业设计小站&lt;/a&gt;  （微信上的一篇文章，如果你想快速了解这些设计原则，推荐此文）&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;http://book.douban.com/subject/3323633/&quot;&gt;图书豆瓣地址&lt;/a&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;以上。&lt;/p&gt;
</description>
				<pubDate>Fri, 20 Dec 2013 00:00:00 +0800</pubDate>
				<link>http://atleeon.com/write/2013/12/20/non-designer-book/</link>
				<guid isPermaLink="true">http://atleeon.com/write/2013/12/20/non-designer-book/</guid>
			</item>
		
			<item>
				<title>Java中hashcode()和equals()的联系</title>
				<description>&lt;h2 id=&quot;intro&quot;&gt;Intro&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;Object&lt;/code&gt;是Java中最原始的类，在Object中，有默认的&lt;code&gt;hashCode&lt;/code&gt;和&lt;code&gt;equals&lt;/code&gt;方法实现，二者是相互关联的。
&lt;!-- break --&gt;
JDK中&lt;code&gt;Object.java&lt;/code&gt;定义了这两个方法：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public native int hashCode();

public boolean equals(Object obj) {
    return (this == obj);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;其中hashCode方法是native方法，具体是实现是返回一个对象的内存地址作为其hashcode.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;As much as is reasonably practical, the hashCode method defined by class Object does return distinct integers for distinct objects. (This is typically implemented by converting the internal address of the object into an intege&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;而equals方法则是简单的直接比较两个对象的地址。&lt;/p&gt;

&lt;h2 id=&quot;missleading&quot;&gt;Missleading&lt;/h2&gt;

&lt;p&gt;看到这这里可能会有疑问，一些教程说&lt;strong&gt;Java中 == 表示比较对象的内存地址，而equals比较具体的内容&lt;/strong&gt;,这个说法其实不准确。equals的存在的作用在于允许程序员自己根据需要定义比较方法，由程序员自己决定两个对象满足什么条件算作是&lt;strong&gt;相等&lt;/strong&gt;。一些书上这么写是因为使用&lt;code&gt;String&lt;/code&gt;类的 == 和equals举例的。String.equals()只比较字符串的&lt;strong&gt;具体内容&lt;/strong&gt;是由它的实现决定的。&lt;/p&gt;

&lt;p&gt;String类继承自Object,并且覆写了其equals方法,使用的就是简单的循环匹配字符。代码如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public boolean equals(Object anObject) {
    if (this == anObject) {
        return true;
    }
    if (anObject instanceof String) {
        String anotherString = (String)anObject;
        int n = count;
        if (n == anotherString.count) {
            char v1[] = value;
            char v2[] = anotherString.value;
            int i = offset;
            int j = anotherString.offset;
            while (n-- != 0) {
                if (v1[i++] != v2[j++])
                    return false;
            }
            return true;
        }
    }
    return false;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;举个例子，为某个应用定义一个&lt;code&gt;User&lt;/code&gt;类，简单代码如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public class User {
    private int id;

    public User(int id) {
        this.id = id;
    }
    public int getId() {
        return id;
    }
    public void setId(int id) {
        this.id = id;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;一般在数据库中，用id标识用户的唯一身份。所以理解上ID相同的User为同一个User。如果接下来直接比较两个id相同的User对象，结果应该可以想到：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    User user1 = new User(1);
    User user2 = new User(1);
    System.out.println(user1.equals(user2));
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;结果是&lt;code&gt;false&lt;/code&gt;,原因是没有覆写equals方法，导致使用的Object中默认的实现，通过==进行比较。现在加上覆写的equals方法，结果就是true了。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;@Override
public boolean equals(Object obj) {
    if (this == obj)
        return true;
    if (obj == null)
        return false;
    if (getClass() != obj.getClass())
        return false;
    User other = (User) obj;
    if (id != other.id)
        return false;
    return true;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;bad-case&quot;&gt;Bad Case&lt;/h2&gt;

&lt;p&gt;一般在处理自定义的类的时候，做到这一步就结束了，但是却留下了隐患，继续刚才的例子，现在要管理一些用户，进行集合的操作。比如用户分组：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    HashSet&amp;lt;User&amp;gt; group = new HashSet&amp;lt;User&amp;gt;();
    
    User user1 = new User(1);
    User user2 = new User(1);
    group.add(user1);
    group.add(user2);
    System.out.println(group.size());
    User another = new User(1);
    System.out.println(group.contains(another));
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我们期待是group的size是1，因为重复添加了同样的用户（HashSet满足集合中元素的唯一性，所以重复元素应该只存一个），并且期待最后打印&lt;code&gt;true&lt;/code&gt;,因为集合中已经存在了id为1的用户。&lt;/p&gt;

&lt;p&gt;但是结果并不如愿，group的size是2，而最后判断组中是否包含用户的结果是&lt;code&gt;false&lt;/code&gt;.这跟HashSet的具体实现有关，简单的说是这样，HashSet确保元素的唯一性，它实际上用一个HashMap来保存所有的元素，并且把元素作为map的key存储。例如其源码&lt;code&gt;HashSet.java&lt;/code&gt;中用的就是map本身的检查key的方法：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public boolean contains(Object o) {
    return map.containsKey(o);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这个方法把问题转换为，判断map中是否有指定的key,所以需要了解HashMap是如何去检测一个key是不是存在的：&lt;code&gt;HashMap.java&lt;/code&gt;中相关的源码如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public boolean containsKey(Object key) {
    return getEntry(key) != null;
}
/**
 * Returns the entry associated with the specified key in the
 * HashMap.  Returns null if the HashMap contains no mapping
 * for the key.
 */
final Entry&amp;lt;K,V&amp;gt; getEntry(Object key) {
    int hash = (key == null) ? 0 : hash(key.hashCode());
    for (Entry&amp;lt;K,V&amp;gt; e = table[indexFor(hash, table.length)];
         e != null;
         e = e.next) {
        Object k;
        if (e.hash == hash &amp;amp;&amp;amp;
            ((k = e.key) == key || (key != null &amp;amp;&amp;amp; key.equals(k))))
            return e;
    }
    return null;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在getEntry方法中，如果找到满足条件的key,就匹配成功能更。可以看到getEntry方法第一步就是计算hash值,做比较时第一个条件是&lt;code&gt;e.hash == hash&lt;/code&gt;。没错，要先比较hash值，如果结果为&lt;code&gt;false&lt;/code&gt;，由于逻辑短路，&lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt;后面的就不会被计算了，直接得出表达式值为&lt;code&gt;false&lt;/code&gt;,为了检验这部分代码，你可以在覆写的equals方法里面加上一句：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; System.out.println(&quot;invoke me?&quot;);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;执行就会发现，equals方法其实都没有被调用，上面的条件里就已经直接为&lt;code&gt;false&lt;/code&gt;了。hash值不同的原因很简单，因为我们没有覆写hashCode方法，所以调用默认实现，创建的新对象就会有不同的hash值。解决办法是动手实现hashCode()。查阅官方文档会发现一个常被忽略的原则，那就是下面的the hashCode and equals contract in Java。&lt;/p&gt;

&lt;h2 id=&quot;the-hashcode-and-equals-contract-in-java&quot;&gt;the hashCode and equals contract in Java&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;ul&gt;
    &lt;li&gt;If two objects are equal according to the equals(Object) method, then calling the hashCode method on each of the two objects must produce the same integer result.&lt;/li&gt;
  &lt;/ul&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;ul&gt;
    &lt;li&gt;It is not required that if two objects are unequal according to the equals(java.lang.Object) method, then calling the hashCode method on each of the two objects must produce distinct integer results.&lt;/li&gt;
  &lt;/ul&gt;
&lt;/blockquote&gt;

&lt;p&gt;文档中提到的约定的大致意思是：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;如果两个对象通过equals方法比较是相等的，那么他们调用hashCode方法就要得到相同的hash返回值。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;相反，如果两个对象调用hashCode有相同的返回值，&lt;strong&gt;不一定&lt;/strong&gt;要求他们equals比较相等。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;也就是说，当你为一个自定义类覆写equals方法时，也要记得覆写相应的hashCode方法，保持一致。&lt;/p&gt;

&lt;h2 id=&quot;solution&quot;&gt;Solution&lt;/h2&gt;

&lt;p&gt;实际编码中，如果你使用eclipse环境开发，创建自己定义的类后，可以使用IDE提供的generate code 功能，自动生成两个方法，比如hashCode()：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;@Override
public int hashCode() {
    final int prime = 31;
    int result = 1;
    result = prime * result + id;
    return result;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;构造hash的时候使用prime number(素数)，可以有更好的均匀分布效果。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;代码&lt;/strong&gt;：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;a href=&quot;https://github.com/leeon/JavaTaste/tree/master/src/hit/jt/obj&quot;&gt;JavaTaste@Github&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;参考资料&lt;/strong&gt;：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;http://www.programcreek.com/2013/09/java-hashcode-equals-contract-set-contains/&quot;&gt;programcreek.com&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://docs.oracle.com/javase/6/docs/api/java/lang/Object.html#hashCode%28%29&quot;&gt;JDK DOC 6&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;以上。&lt;/p&gt;
</description>
				<pubDate>Fri, 29 Nov 2013 00:00:00 +0800</pubDate>
				<link>http://atleeon.com/code/2013/11/29/java-equals-hashcode/</link>
				<guid isPermaLink="true">http://atleeon.com/code/2013/11/29/java-equals-hashcode/</guid>
			</item>
		
			<item>
				<title>JavaScript中的原型和原型链</title>
				<description>&lt;blockquote&gt;
  &lt;p&gt;假设读者已经掌握基本的JavaScript语言基础和面向对象知识&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;受了太多&lt;a href=&quot;http://en.wikipedia.org/wiki/Object-oriented_programming&quot;&gt;OO&lt;/a&gt;思想的影响,提到一种编程语言，就容易想到它有类吗？他支持继承吗？&lt;/p&gt;

&lt;!-- break --&gt;
&lt;p&gt;在JavaScript语言中，上面的答案是『没有类，但是支持继承』。JavaScript的设计中是没有&lt;strong&gt;class&lt;/strong&gt;的概念的，其实&lt;strong&gt;继承&lt;/strong&gt;也是后来随着面向对象的大趋势发展而引入的。没有类如何实现继承？所以JavaScript引入了&lt;strong&gt;原型&lt;/strong&gt;的概念。&lt;/p&gt;

&lt;p&gt;那么请先记住一句话 「Everything is an Object」.&lt;/p&gt;

&lt;h3 id=&quot;section&quot;&gt;原型和原型链&lt;/h3&gt;

&lt;p&gt;类似JavaScript这样基于原型继承的语言,有个特点是每个object都会有自己的一个神秘『引用』,当自己找不到一些属性的时候,就会通过这个『引用』去寻找。而这个『引用』指向的也是一个object，因此这个object也有自己的『引用』，就形成了一个『递归』。&lt;/p&gt;

&lt;p&gt;好，上面说的『引用』就是&lt;strong&gt;原型&lt;/strong&gt;，这个『递归』形成了&lt;strong&gt;原型链&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;JavaScript事实上隐藏了对于原型的访问，但是Mozilla使用了__proto__这个神奇的属性让开发者可以访问到object的原型。注意__proto__是不符合ECMA标准的，因此不要使用他。但是我们可以通过__proto__来了解JavaScript的原型机制。&lt;/p&gt;

&lt;h3 id=&quot;prototypeproto&quot;&gt;prototype和__proto__&lt;/h3&gt;

&lt;p&gt;关于这两个概念，明确以下几个关键点就可以掌握&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;prototype是只属于function的，而__proto__属于所有object的.&lt;/li&gt;
  &lt;li&gt;__proto__是真正的原型&lt;/li&gt;
  &lt;li&gt;function的prototype属性表示该function所创建的对象的原型。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;例如下面的代码&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;function Foo(){}
var foo = new Foo()

console.log(Foo.prototype) // {}  means object
console.log(foo.prototype) // undifined
console.log(Foo.__proto__) // Function.prototype
console.log(foo.__proto__) // Foo.prototype
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;第一和第二条log演示了关键点1，第三条说明了演示了关键点2，最后一条演示了关键点3。当foo被创建的时候，会有这样的操作：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;foo.__proto__ = Foo.prototype
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 class=&quot;center&quot; id=&quot;section-1&quot;&gt;图谱&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;http://www.mollypages.org/misc/jsobj.jpg&quot; alt=&quot;&quot; style=&quot;max-width:700px&quot; /&gt;&lt;/p&gt;

&lt;p class=&quot;center&quot;&gt;神图&lt;/p&gt;

&lt;p&gt;这就是JavaScript中的原型链图谱，这张图也很好的解释了一直缠绕不清的「function」和「object」关系。可以看到中间背景为蓝色的部分标记了Function,你可能会诧异，Object怎么也是function了,我的理解是JavaScript把可以创建对象的对象都当做function对待，比如Foo和Object都可以创建对象实例：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var f = new Foo()
var o = new Object()
console.log(typeof Object) //Function
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;有了这样的理解接下来就比较好讲解了，如何读这张图：比如foo 经过__proto__到Foo.prototype的虚线表示foo.__proto__是Foo.prototype.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;插入一个constructor的概念，任何对象或者函数也好，都是被创建的，既然被创建，那么就一定有自己的构造函数，constructor就是构造函数，&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;解读这张图最好的方式就是用代码实际的实验&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;//code to explian js prototype chain
//@author leeon
//@run node test.js
function Foo () {}
Foo.prototype.info = &quot;Foo.prototype&quot;
Object.prototype.info = &quot;Object.prototype&quot;
Function.prototype.info =&quot;Function.prototype&quot;
var f1 = new Foo()
var o1 = new Object()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;为了直观的看到结果，我们先设置好几个原型的信息。首先按照图中的线路进行验证：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;//validate basic 
console.log(f1.__proto__) //Foo.prototype
console.log(Foo.prototype) //Foo.prototype
console.log(Foo.constructor) //Function
console.log(Foo.__proto__) //Function.prototype
console.log(&#39;---------&#39;)
console.log(o1.__proto__)  //Object.prototype
console.log(Object.prototype) //Object.prototype
console.log(Object.constructor) //Fucntion
console.log(Object.__proto__) //Function
console.log(&#39;---------&#39;)
console.log(Function.prototype)  //Function.prototype
console.log(Function.constructor) //Function
console.log(Function.__proto__) //Function
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;有趣的现象是，Foo.__proto__和foo__proto__并不一致。正如前面已经提到过，当被foo被创建的时候，foo的原型链指向了Foo.prototype了，而Foo其实是被Function创建的。&lt;/p&gt;

&lt;h3 id=&quot;section-2&quot;&gt;原型链和变量查找&lt;/h3&gt;

&lt;p&gt;看下面的例子会有怎样的结果：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; function Foo(){}
 var foo = new Foo()
 Foo.prototype.info = &quot;123&quot;
 console.log(foo.info)
 console.log(Foo.info) 结果很意外，Foo.info竟然是undefined。其实，仔细思考就会发现，肯定是undefined，前面提到过解释器搜索变量，是根据原型链进行的，而观察图中的Foo的原型链中却没有Foo.prototype.对于这样的设计我自己的理解是JavaScript还是区分了类型和实例的概念，Foo是一个类型或者函数，而foo是一个实例。如果直接按照下面访问就可以获得info:

console.log(Foo.prototype.info)
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;section-3&quot;&gt;继续探索&lt;/h3&gt;
&lt;p&gt;接下来看看图中没有的曲线是什么效果，前面已经提到过，所以很容易猜到，f1.prototype是undefined了。那么他的构造函数有没有呢？&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;//if a instance of function has prototype or constructor
console.log(f1.prototype) //undefined
console.log(f1.constructor) //Foo

//if a instance of object has prototype or constructor
console.log(o1.prototype)
console.log(o1.constructor)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;答案是Foo,没错，一切的对象都有来源的，这个来源就是constructor了，就连Foo作为一个类型本身都是来自Function创建的的，正如他的__proto__指向了Function.prototype。&lt;/p&gt;

&lt;p&gt;下面的代码告诉你了原型链的尽头是神马，图中也有：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;//see a chain 
console.log(Foo.__proto__.__proto__.__proto__) //null
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;section-4&quot;&gt;结束&lt;/h3&gt;

&lt;p&gt;最后让我们以JavaScript中经典的『鸡蛋问题』结尾吧:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;console.log(Function instanceof Object)  //TRUE
console.log(Object instanceof Function)  //TRUE
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
  &lt;p&gt;提示：instanceof判断A是不是属于类型B，要看B在不在他的原型链中，Object.prototypes是一个object,Function.prototype是一个function.看图说话。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h5 id=&quot;section-5&quot;&gt;参考资料&lt;/h5&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;http://www.quora.com/JavaScript-programming-language/What-is-the-difference-between-__proto__-and-prototype&quot;&gt;Quora:What is the difference between “&lt;strong&gt;proto&lt;/strong&gt;” and “prototype”?&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://www.mollypages.org/misc/js.mp&quot;&gt;http://www.mollypages.org/misc/js.mp&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://www.laruence.com/2010/05/13/1462.html&quot;&gt;http://www.laruence.com/2010/05/13/1462.html&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://www.ruanyifeng.com/blog/2011/06/designing_ideas_of_inheritance_mechanism_in_javascript.html&quot;&gt;http://www.ruanyifeng.com&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;以上。&lt;/p&gt;
</description>
				<pubDate>Sat, 05 Oct 2013 00:00:00 +0800</pubDate>
				<link>http://atleeon.com/code/2013/10/05/javascript-prototype/</link>
				<guid isPermaLink="true">http://atleeon.com/code/2013/10/05/javascript-prototype/</guid>
			</item>
		
	</channel>
</rss>