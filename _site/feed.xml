<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
	<channel>
		<title>GuoJing's Blog</title>
		<description>Leeon</description>
		<link>http://atleeon.com</link>
		<atom:link href="http://atleeon.com/feed.xml" rel="self" type="application/rss+xml" />
		
			<item>
				<title>且听风吟</title>
				<description>&lt;blockquote&gt;
  &lt;p&gt;时光真疯狂，我一路执迷与匆忙&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;最近他常哼起这首歌，特别是晚上走路的时候。校园周围很多街道，唯独他记不得这条路的名字，能想起的只有夏夜摇曳的树影，偶尔轻抚皮肤上汗毛的风，温柔的无法抵抗。&lt;/p&gt;

&lt;p&gt;仿如一零年夏天，那些想不起名字的水泥地，台阶、路口的红绿灯、大院的门，小区，水池，当然，还有一个他确信自己仍记得清楚的冰淇淋店。里面发脾气的，耐心的，烦躁的，喜悦的男男女女中间，一张桌子上，放着一本留言册，胡言乱语。&lt;/p&gt;

&lt;p&gt;青春的梦想，单纯的大多只有梦和想，沉溺的会忘记仲夏的烦躁，身体间的汗味也让人迷醉。说起来，那个夏天好热啊，他们都这么说，你问他有多热，他肯定会说 “我好想去吃冰淇淋啊”。&lt;/p&gt;

&lt;p&gt;放假那天，他淋着大雨匆匆忙忙的叫到一辆的士，拼命钻进去，前往车站。临行前，他想看看窗外，可那车窗模糊的像跌进了深深的水里。后来才知道，这雨水让他的夏天以及相关的一切模糊了一片。&lt;/p&gt;

&lt;p&gt;后来，他试图过去寻找那些台阶啊，小区啊，但是却发现自己从没来过，只有那家冰淇淋店还在。于是他按照自己的记忆挑了个位置，桌子上真的有一本小册子，他确信自己找到了，可那日期拆穿了他。走出店门后，他发现那夏天再也找不见了。&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;后来，他不知不觉就很忙了。但是他还是常常在想那些被雨冲走的日子呢？他常停下来，猜测这这风中就有线索。&lt;/p&gt;

&lt;p&gt;“这条路究竟是要去哪儿，大风声，像没发生 太多的记忆。。。”他感觉有点凉了，哼着歌走了。&lt;/p&gt;

&lt;p&gt;又后来，他就没再找了。&lt;/p&gt;

&lt;p class=&quot;center&quot;&gt;&lt;img src=&quot;http://cdn4atleeon.qiniudn.com/image/story/2014/wind.jpg&quot; alt=&quot;雨&quot; style=&quot;max-width:700px&quot; /&gt;&lt;/p&gt;

&lt;p class=&quot;center&quot;&gt;Photo by searna&lt;/p&gt;

&lt;p&gt;以上。&lt;/p&gt;
</description>
				<pubDate>Tue, 13 May 2014 00:00:00 +0800</pubDate>
				<link>http://atleeon.com/story/2014/05/13/listen-to-wind/</link>
				<guid isPermaLink="true">http://atleeon.com/story/2014/05/13/listen-to-wind/</guid>
			</item>
		
			<item>
				<title>Python中的元类</title>
				<description>&lt;p&gt;翻译一篇来自StackOverflow的回答，原问题地址&lt;a href=&quot;http://stackoverflow.com/questions/100003/what-is-a-metaclass-in-python&quot;&gt;What is a metaclass in Python&lt;/a&gt;. 投票最高的答案非常完整描述了Python Metaclass机制。说起元类，大致可以才想到其作用，关于类的类。&lt;strong&gt;元&lt;/strong&gt;或者&lt;strong&gt;meta&lt;/strong&gt;常用来表示关于一个事物本身的属性。比如一份学生名单，这份数据的格式doc, 字数1000字，这就是这份数据的元数据，而文本描述的学生信息就是具体的数据本身，元数据描述了这份数据。你有可能听说过元编程,道理也是一样，编写去生产代码的程序。那么元类呢？&lt;/p&gt;

&lt;!-- break --&gt;

&lt;p&gt;下面为原文部分&lt;/p&gt;

&lt;h2 id=&quot;section&quot;&gt;类也是对象&lt;/h2&gt;
&lt;p&gt;在理解元类之前，你需要掌握Python中类的概念。Python中对于类的处理借鉴了Smalltalk语言。在大多数编程语言中，类只是用来生成对象的代码，从这方面来讲，Python也是一样的：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; class ObjectCreator(object):
...     pass
...
&amp;gt;&amp;gt;&amp;gt; my_object = ObjectCreator() #实例化一个对象
&amp;gt;&amp;gt;&amp;gt; print(my_object)
&amp;lt;__main__.ObjectCreator object at 0x8974f2c&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;但是Python类还有更特殊的身份：类也是对象。当你使用&lt;strong&gt;class&lt;/strong&gt;关键字的时候，Python会执行并创建一个对象.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; class ObjectCreator(object):
...     pass
...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面的代码在内存中创建一个名字为ObjectCreator的对象.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;这个对象(类)本身具有创建对象(实例)的能力，因此它成为一个类&lt;/strong&gt;. 但是其本身仍然是个对象，因此:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;可以将类赋值给一个变量&lt;/li&gt;
  &lt;li&gt;可以复制类&lt;/li&gt;
  &lt;li&gt;可以给类添加属性&lt;/li&gt;
  &lt;li&gt;可以把类作为函数参数传递&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;举例:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; print(ObjectCreator) # 你可以打印一个类，因为它也是一个对象
&amp;lt;class&#39;__main__.ObjectCreator&#39;&amp;gt;
&amp;gt;&amp;gt;&amp;gt; def echo(o):
... print(o)
...
&amp;gt;&amp;gt;&amp;gt; echo(ObjectCreator) # 也可以把类作为函数参数
&amp;lt;class&#39;__main__.ObjectCreator&#39;&amp;gt;
&amp;gt;&amp;gt;&amp;gt; print(hasattr(ObjectCreator,&#39;new_attribute&#39;))
False
&amp;gt;&amp;gt;&amp;gt; ObjectCreator.new_attribute =&#39;foo&#39; # 可以给类添加新的属性
&amp;gt;&amp;gt;&amp;gt; print(hasattr(ObjectCreator,&#39;new_attribute&#39;))
True
&amp;gt;&amp;gt;&amp;gt; print(ObjectCreator.new_attribute)
foo
&amp;gt;&amp;gt;&amp;gt; ObjectCreatorMirror = ObjectCreator # 把类赋值给其他变量
&amp;gt;&amp;gt;&amp;gt; print(ObjectCreatorMirror.new_attribute)
foo 
&amp;gt;&amp;gt;&amp;gt; print(ObjectCreatorMirror())
&amp;lt;__main__.ObjectCreator object at 0x8997b4c&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;section-1&quot;&gt;动态的创建类&lt;/h2&gt;

&lt;p&gt;因为类也是对象，所以我们可也像创建其他对象那样创建类。首先，可以在函数中使用 &lt;strong&gt;class&lt;/strong&gt; 创建类：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; def choose_class(name):
...     if name ==&#39;foo&#39;:
...         class Foo(object):
...             pass
...         return Foo # 返回类本身，而不是实例
...     else:
...         class Bar(object):
...             pass
...         return Bar
...
&amp;gt;&amp;gt;&amp;gt; MyClass = choose_class(&#39;foo&#39;)
&amp;gt;&amp;gt;&amp;gt; print(MyClass) # 函数返回一个类而不是实例
&amp;lt;class&#39;__main__.Foo&#39;&amp;gt;
&amp;gt;&amp;gt;&amp;gt; print(MyClass()) # 可以通过这个类创建对象
&amp;lt;__main__.Foo object at 0x89c6d4c&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;但这并不是真正的动态创建，你还是需要自己编写全部所需的代码。因为类也是对象，所以它一定可以通过某种方式生成，当你使用&lt;strong&gt;class&lt;/strong&gt;关键字的时候，Python自动创建对象。但是就像Python中很多机制一样，它允许你自己手动控制。&lt;/p&gt;

&lt;p&gt;还记得&lt;code&gt;type&lt;/code&gt;函数吗？这个有点历史并且很棒的函数可以判断一个对象是什么类型：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; print(type(1)) 
&amp;lt;type &#39;int&#39;&amp;gt;
&amp;gt;&amp;gt;&amp;gt; print(type(&quot;1&quot;)) 
&amp;lt;type &#39;str&#39;&amp;gt;
&amp;gt;&amp;gt;&amp;gt; print(type(ObjectCreator)) 
&amp;lt;type &#39;type&#39;&amp;gt;
&amp;gt;&amp;gt;&amp;gt; print(type(ObjectCreator())) 
&amp;lt;class&#39;__main__.ObjectCreator&#39;&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;其实，&lt;code&gt;type&lt;/code&gt;还有一个完全不同的功能，它可以在运行时创建类。&lt;code&gt;type&lt;/code&gt;可以接受一个描述类的参数，并且返回一个类。(针对不同的参数有两个完全不同功能的函数看起来挺愚蠢。这是Python向后兼容的问题)。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;type&lt;/code&gt;方法工作方式如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;type(name of the class,      
    tuple of the parent class(for inheritance, can be empty),      
    dictionary containing attributes names and values)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;例如：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; class MyShinyClass(object):
...     pass
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这个类可以通过下面的方式创建：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; MyShinyClass= type(&#39;MyShinyClass&#39;,(),{}) # 返回一个对象
&amp;gt;&amp;gt;&amp;gt; print(MyShinyClass)
&amp;lt;class&#39;__main__.MyShinyClass&#39;&amp;gt;
&amp;gt;&amp;gt;&amp;gt; print(MyShinyClass()) # 用创建的类实例化一个对象
&amp;lt;__main__.MyShinyClass object at 0x8997cec&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;注意到，我们使用 &lt;code&gt;MyShinyClass&lt;/code&gt;作为类的名字，并且引用它。这个名字可以不同，但是没有必要把事情变得更加复杂(一个就够了吧)。&lt;code&gt;type&lt;/code&gt;方法接受一个字典参数来定义类的属性：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; class Foo(object):
...       bar = True
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以转换为：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; Foo = type(&#39;Foo&#39;, (), {&#39;bar&#39;:True})
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Foo可以作为一个正常的类的使用。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; print(Foo)
&amp;lt;class&#39;__main__.Foo&#39;&amp;gt;
&amp;gt;&amp;gt;&amp;gt; print(Foo.bar)
True
&amp;gt;&amp;gt;&amp;gt; f = Foo()
&amp;gt;&amp;gt;&amp;gt; print(f)
&amp;lt;__main__.Foo object at 0x8a9b84c&amp;gt;
&amp;gt;&amp;gt;&amp;gt; print(f.bar)
True
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;当然你也可以继承这个类：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; class FooChild(Foo):
...     pass
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;换成动态写法：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; FooChild = type(&#39;FooChild&#39;,(Foo,),{})
&amp;gt;&amp;gt;&amp;gt; print(FooChild)
&amp;lt;class&#39;__main__.FooChild&#39;&amp;gt;
&amp;gt;&amp;gt;&amp;gt; print(FooChild.bar) # bar继承自Foo
True
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;最后如果想给自己创建的类添加方法，只要定义一个合适的方法并且将其赋值给类的属性就可以了&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; def echo_bar(self):
...     print(self.bar)
... 
&amp;gt;&amp;gt;&amp;gt; FooChild = type(&#39;FooChild&#39;,(Foo,),{&#39;echo_bar&#39;: echo_bar})
&amp;gt;&amp;gt;&amp;gt; hasattr(Foo,&#39;echo_bar&#39;)
False
&amp;gt;&amp;gt;&amp;gt; hasattr(FooChild,&#39;echo_bar&#39;)
True
&amp;gt;&amp;gt;&amp;gt; my_foo =FooChild()
&amp;gt;&amp;gt;&amp;gt; my_foo.echo_bar()
True
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以看到，在Python中我们可以在运行时动态创建类，这就是class关键字真正执行的操作，利用了元类。&lt;/p&gt;

&lt;h2 id=&quot;section-2&quot;&gt;什么是元类&lt;/h2&gt;
&lt;p&gt;元类是用来创建类的，你定义class来创建类，对吧？但是我们了解到Python的类其实也是对象。总之元类就是类的类，你可以用下面的方式描述它：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;MyClass=MetaClass()
MyObject=MyClass()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我们知道&lt;code&gt;type&lt;/code&gt;方法允许我们做下面的这种事情：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;MyClass= type(&#39;MyClass&#39;,(),{})
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这是因为type函数实际上是一个元类，Python用它来创建所有对象。你也许会想为什么&lt;code&gt;type&lt;/code&gt;全写成小写而不是&lt;code&gt;Type&lt;/code&gt;，我猜是为了和&lt;code&gt;str&lt;/code&gt;(创建字符串对象的类)，&lt;code&gt;int&lt;/code&gt;(创建整型对象的类)保持一致.你可以通过&lt;strong&gt;__class__&lt;/strong&gt;属性查看。&lt;/p&gt;

&lt;p&gt;Python中一切都是对象，包括所有的字符串，整型 ，函数和类。他们都是通过某个类创建的：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; age = 35
&amp;gt;&amp;gt;&amp;gt; age.__class__
&amp;lt;type &#39;int&#39;&amp;gt;
&amp;gt;&amp;gt;&amp;gt; name = &#39;bob&#39;
&amp;gt;&amp;gt;&amp;gt; name.__class__
&amp;lt;type &#39;str&#39;&amp;gt;
&amp;gt;&amp;gt;&amp;gt; def foo():
pass
&amp;gt;&amp;gt;&amp;gt; foo.__class__
&amp;lt;type &#39;function&#39;&amp;gt;
&amp;gt;&amp;gt;&amp;gt; classBar(object):
        pass
&amp;gt;&amp;gt;&amp;gt; b = Bar()
&amp;gt;&amp;gt;&amp;gt; b.__class__
&amp;lt;class&#39;__main__.Bar&#39;&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;那么 &lt;code&gt;__class__.__class__&lt;/code&gt;代表什么呢？&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; age.__class__.__class__
&amp;lt;type &#39;type&#39;&amp;gt;
&amp;gt;&amp;gt;&amp;gt; name.__class__.__class__
&amp;lt;type &#39;type&#39;&amp;gt;
&amp;gt;&amp;gt;&amp;gt; foo.__class__.__class__
&amp;lt;type &#39;type&#39;&amp;gt;
&amp;gt;&amp;gt;&amp;gt; b.__class__.__class__
&amp;lt;type &#39;type&#39;&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以看出元类就是创建类的，你可以给它叫做类工厂，&lt;code&gt;type&lt;/code&gt;是Python的内置元类，当然你也可以创建自己的元类。&lt;/p&gt;

&lt;h2 id=&quot;metaclass&quot;&gt;__metaclass__属性&lt;/h2&gt;

&lt;p&gt;创建一个类的时候，可以给它添加 &lt;code&gt;__classmeta__&lt;/code&gt;属性：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;class Foo(object):  
    __metaclass__ = something...
    [...]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这样做，Python就会使用指定的元类创建Foo类。这个要小心处理。你首先要写&lt;code&gt;class Foo(object)&lt;/code&gt;，但是Foo类此时还没有被创建。Python会寻找&lt;code&gt;__metaclass__&lt;/code&gt;的定义，如果找到就是用它创建Foo，如果没有找到，就使用type创建。&lt;/p&gt;

&lt;p&gt;记住下面的步骤：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;class Foo(Bar):
    pass
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Python会做下面的事情：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;检查Foo中是不是有__metaclass__属性&lt;/li&gt;
  &lt;li&gt;如果有，创建一个类对象，名字为Foo,通过__metaclass__指定的类创建&lt;/li&gt;
  &lt;li&gt;如果Python找不到__metaclass__，它会在父类Bar中寻找__metaclass__，重复相同的规则&lt;/li&gt;
  &lt;li&gt;如果在任何父类中都找不到__metaclass__，就会到MODULE中去找，重复相同规则&lt;/li&gt;
  &lt;li&gt;如果还找不到，则使用type创建&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;__metaclass__到底应该放什么呢？就是创建类&lt;/p&gt;

&lt;h2 id=&quot;section-3&quot;&gt;自定义元类&lt;/h2&gt;

&lt;p&gt;元类的主要目的是动态改变类。常见的使用场景是创建API,你需要根据运行环境创建类。考虑一个笨拙的例子，你希望模块中所有的类属性都改为大写的。这有几种实现方式，其中之一就是在模块中设置__metaclass__。&lt;/p&gt;

&lt;p&gt;这样，模块中所有的类都是通过这个元类创建的，我们只需要告诉元类把所有的类属性改为大写。幸运的是，__metaclass__可以以任何形式调用，不一定是正式的class。&lt;/p&gt;

&lt;p&gt;所以我们用一个简单例子开始，使用函数：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# 这个元类接收和type相同的参数
def upper_attr(future_class_name, future_class_parents, future_class_attr):
    &quot;&quot;&quot;    
      返回一个类对象，其属性转换为大写
    &quot;&quot;&quot;
    # 选择不是__开头的属性，并且转换为大写  
    uppercase_attr ={}
    for name, val in future_class_attr.items():
        if not name.startswith(&#39;__&#39;):
            uppercase_attr[name.upper()]= val      
        else:          
            uppercase_attr[name]= val  
    # 使用type创建类
    return type(future_class_name, future_class_parents, uppercase_attr)

    __metaclass__ = upper_attr # 作用于模块中所有的类

class Foo():
    # 我们也可以在这里指定__metaclass__只作用于这一个类
    # 这会影响子类 
    bar =&#39;bip&#39;

print(hasattr(Foo,&#39;bar&#39;))
# Out: False
print(hasattr(Foo,&#39;BAR&#39;))
# Out: True
f = Foo()
print(f.BAR)
# Out: &#39;bip&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;现在实现相同的效果,使用真实的类作为元类：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# 注意type和int ，str一样，所以你可以继承它
class UpperAttrMetaclass(type):# __new__ 在 __init__之前被调用
    # 这个方法负责创建并且返回对象
    # __init__ 方法只是初始化对象参数
    # 平时很少用 __new__, 除非你想要控制对象的创建
    def __new__(upperattr_metaclass, future_class_name,                 
                future_class_parents, future_class_attr):

        uppercase_attr ={}
        for name, val in future_class_attr.items():
            if not name.startswith(&#39;__&#39;): 
                uppercase_attr[name.upper()]= val            
            else:
                uppercase_attr[name]= val

        return type(future_class_name, future_class_parents, uppercase_attr)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;实际上这种方式并不是真正的面向对象，我们直接调用了type，没有重载父类的__new__方法，这样改写一下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;class UpperAttrMetaclass(type):# __new__ 在 __init__之前被调用

    def __new__(upperattr_metaclass, future_class_name,                 
                future_class_parents, future_class_attr):

        uppercase_attr ={}
        for name, val in future_class_attr.items():
            if not name.startswith(&#39;__&#39;): 
                uppercase_attr[name.upper()]= val            
            else:
                uppercase_attr[name]= val

        # 重用type.__new__ method
        return type.__new__(upperattr_metaclass, future_class_name,
                            future_class_parents, uppercase_attr)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;你可能发现了额外的参数uperattr_metaclass,这个参数是对象方法总是将当前实例作为第一个参数传入。当然我使用的这个名字不够明确，就像self，所有参数都有规定名字，所以真实的元类应该是这样的&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;class UpperAttrMetaclass(type):# __new__ 在 __init__之前被调用

    def __new__(cls, clsname, bases, dct):

        uppercase_attr ={}
        for name, val in future_class_attr.items():
            if not name.startswith(&#39;__&#39;): 
                uppercase_attr[name.upper()]= val            
            else:
                uppercase_attr[name]= val

        return type.__new__(cls, clsname, bases, uppercase_attr)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我们可以使用super关键字使代码变得更加清晰&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;class UpperAttrMetaclass(type):# __new__ 在 __init__之前被调用

    def __new__(cls, clsname, bases, dct):

        uppercase_attr ={}
        for name, val in future_class_attr.items():
            if not name.startswith(&#39;__&#39;): 
                uppercase_attr[name.upper()]= val            
            else:
                uppercase_attr[name]= val

        return super(UpperAttrMetaclass,cls).__new__(cls, clsname, bases, uppercase_attr)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;关于元类真的就是这么多了，使用元类的代码错综复杂的原因不是因为元类，而是因为你通常使用元类在自省，继承和__dict__这样的变量上进行依赖反转。&lt;/p&gt;

&lt;p&gt;事实上元类在使用一些”黑魔法”时很有用，这也使事情更复杂，但是他们本身很简单：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;拦截一个类创建的过程&lt;/li&gt;
  &lt;li&gt;修改类&lt;/li&gt;
  &lt;li&gt;返回修改后的类&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section-4&quot;&gt;为什么使用类做元类而不是函数&lt;/h2&gt;

&lt;p&gt;元类接受任何形式调用（上面显示了两种基本方式，通过函数和类），使用类作为元类显然更加复杂，为什么这样做的？&lt;/p&gt;

&lt;p&gt;原因有几个：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;意图清晰，当你阅读&lt;code&gt; UpperAttrMetaclass(type)&lt;/code&gt;,你知道接下来要做什么&lt;/li&gt;
  &lt;li&gt;利用面向对象，元类可以继承自元类，覆写父类的方法，元类甚至可以使用元类&lt;/li&gt;
  &lt;li&gt;可以更好的控制代码结构，你不可能用元类处理像上面那样微不足道的例子，通常是处理比较复杂的情景，使用类可以将不同方法封装到一起，是的代码更加容易阅读&lt;/li&gt;
  &lt;li&gt;你可以在&lt;code&gt;__new__&lt;/code&gt;,&lt;code&gt;__init__&lt;/code&gt;,&lt;code&gt;__call__&lt;/code&gt;使用hook，这样可以处理不同的事情，或许你可能喜欢把所有代码写到&lt;code&gt;__new__&lt;/code&gt;里，其他人可能觉得&lt;code&gt;__init__&lt;/code&gt;更方便&lt;/li&gt;
  &lt;li&gt;这东西本来就叫元“类”！&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section-5&quot;&gt;到底为什么用元类&lt;/h2&gt;
&lt;p&gt;最大的问题来了，为什么使用这么复杂的特性呢？&lt;/p&gt;

&lt;p&gt;事实上，通常不会使用：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;元类是99%开发者不会考虑的特性，如果你疑惑自己是不是需要他们，那么一般答案是，不需要。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;元类的主要用处是创建API,一个典型的例子是Django ORM. 它允许你这样定义类：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;class Person(models.Model):
    name = models.CharField(max_length=30)
    age = models.IntegerField()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;但是如果你这样做：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;guy = Person(name=&#39;bob&#39;,age=&#39;35&#39;)
print(guy.age)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;它就不会返回一个&lt;code&gt;IntegerField&lt;/code&gt;，而是返回一个&lt;code&gt;int&lt;/code&gt;，甚至直接从数据库中读取。这是有可能的，因为&lt;code&gt;models.Model&lt;/code&gt;定义了&lt;code&gt;__metaclass__&lt;/code&gt;，并且它可能会改变你定义的&lt;code&gt;Person&lt;/code&gt;类，使得它Hook到数据库的某个字段。Django将复杂的hook用简单的API呈现，并且使用元类重新创建代码来完成背后真正复杂的工作。&lt;/p&gt;

&lt;h2 id=&quot;section-6&quot;&gt;最后&lt;/h2&gt;
&lt;p&gt;首先你要知道类是对象，并且可以创建对象，然而事实上类自己也是一个实例&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; class Foo(object):pass
&amp;gt;&amp;gt;&amp;gt; id(Foo)
142630324
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Python中一切都是对象，他们要么是类的实例，要么是元类的实例。&lt;/p&gt;

&lt;p&gt;type除外。type是它自己的元类，这是在实现层完成的。其次元类是复杂的，你可能不希望使用它进行简单的类变换，你可以使用下面的方式改变类：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Monkey patching&lt;/li&gt;
  &lt;li&gt;类装饰器&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;如果你需要修改类，99%的情况下，你最好使用上面两个方法，但是99%的情况下，你根本不需要修改类。。。。。&lt;/p&gt;
</description>
				<pubDate>Fri, 14 Mar 2014 00:00:00 +0800</pubDate>
				<link>http://atleeon.com/code/2014/03/14/trans-python-metaclass/</link>
				<guid isPermaLink="true">http://atleeon.com/code/2014/03/14/trans-python-metaclass/</guid>
			</item>
		
	</channel>
</rss>